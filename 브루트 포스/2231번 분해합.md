# 2231번 분해합

## 문제

어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.

## 입력

첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

## 출력

첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

## 예제 입력 1

```
216
```

## 예제 출력 1

```
198
```

---

## 풀면서 생각한 것들

반대로 주어진 수에서 정답의 첫째 자리 수, 둘째 자리 수, 셋째 자리 수, ~ , n번째 자리 수를 뺀 수와 정답과 같아야 하는 조건이 있음

그런데 생성자가 없을 수도 있고 여러 개 일수도 있는 경우는 생각나지 않는다.

정말 단순하게 생각하면 1부터 9까지 for문을 돌려서 모든 경우를 찾는 것이다.

하지만 N이 1000000까지라 별로 일 것 같다..

규칙을 더 찾아보자...

아니면 반대로 접근해서 입력받은 수의 자리 수만큼 10000~ 부터 시작해서 찾기 그 안에서 경우의 수를 줄일 방법을 찾아보자

216 - 9 = 207 O

216 - 10 = 206

216 - 11 = 205

216 - 12 = 204

216 - 13 = 203

216 - 14 = 202

216 - 15 = 201

216 - 16 = 200

216 - 17 = 199

216 - 18 = 198 O

216 - 19 = 197

216 - 20 = 196

216 - 21 = 195

216 - 22 = 194

216 - 23 = 193

216 - 24 = 192

216 - 25 = 191

216 - 26 = 190

216 - 27 = 189

최대 9 * 자리 수까지 검사하면 됨

# 내 코드

```java
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int n = input.nextInt();
		solution(n);
	}
	public static void solution(int n) {
		String str = Integer.toString(n);
		int min = Integer.MAX_VALUE;
		int temp = 0;
		int temp2 = 0;
		String ss = " ";
		for(int i = 1; i <= (9*str.length()); i++) {
            	       // 숫자의 한 자리 수 는 0~9까지 이므로 이 반복문은 각 자리수 * 9를 해서 반복하도록 함
            	       // 000 ~ 999 처럼 생각하면 된다
			temp = n-i;
			ss = Integer.toString(temp);
			for(int z =0; z < ss.length(); z++) {
				temp2 += ss.charAt(z) - 48;
                                       //char 형으로 뺄 경우 아스키 코드표에 숫자의 값으로 연산이 됨
                              	    // 0 ~ 9 => 48 ~ 57
                		   // 48을 빼주면 원래 숫자처럼 연산할 수 있어서 빼줘서 생성자인지 확인하기 위해 각 자리수의 합을 구함
			}
			if(temp2 == i) {
				min = Math.min(min, temp);//생성자들 중에 가장 작은 값을 찾기 위해 사용
			}
			temp2 = 0; // 반복해서 탐색해야 하니까 한 번 끝나면 다시 0으로 초기화
		}
		if(min == Integer.MAX_VALUE) {
                   //생성자가 없는 경우 min 값이 바뀌지 않기 때문에 없는 경우 0을 출력해야 하므로 조건문을 사용.
			min = 0; 
		}
		System.out.println(min);
	}
}
```

